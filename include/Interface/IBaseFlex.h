#ifndef _INCLUDE_BASE_FLEX_H_
#define _INCLUDE_BASE_FLEX_H_

#include "IBaseAnimatingOverlay.h"

class IBaseFlex;

class CSceneEventInfo
{
public:
	CSceneEventInfo()
		:
	m_pEvent( 0 ),
	m_pScene( 0 ),
	m_pActor( 0 ),
	m_bStarted( false ),
	m_iLayer( -1 ),
	m_iPriority( 0 ),
	m_nSequence( 0 ),
	m_bIsGesture( false ),
	m_flWeight( 0.0f ),
	m_hTarget(),
	m_bIsMoving( false ),
	m_bHasArrived( false ),
	m_flInitialYaw( 0.0f ),
	m_flTargetYaw( 0.0f ),
	m_flFacingYaw( 0.0f ),
	m_nType( 0 ),
	m_flNext( 0.0f ),
	m_bClientSide( false )
	{
	}

	// The event handle of the current scene event
	/*CChoreoEvent*/void	*m_pEvent;

	// Current Scene
	/*CChoreoScene*/void	*m_pScene;

	// Current actor
	/*CChoreoActor*/void	*m_pActor;

	// Set after the first time the event has been configured ( allows
	//  bumping markov index only at start of event playback, not every frame )
	bool			m_bStarted;

public:
	int						m_iLayer;
	int						m_iPriority;
	int						m_nSequence;
	bool					m_bIsGesture;
	float					m_flWeight;

	EHANDLE					m_hTarget;
	bool					m_bIsMoving;
	bool					m_bHasArrived;
	float					m_flInitialYaw;
	float					m_flTargetYaw;
	float					m_flFacingYaw;

	int						m_nType;
	float					m_flNext;

	bool					m_bClientSide; 

	void					InitWeight( IBaseFlex *pActor );
	float					UpdateWeight( IBaseFlex *pActor );
};

class CChoreoEvent;
class CChoreoActor;
class CChoreoScene;
class AI_Response;

class IBaseFlex : public IBaseAnimatingOverlay
{
public:
	DECLARE_CLASS(IBaseFlex, IBaseAnimatingOverlay);

	void					SetFlexWeight( const char *szName, float value );
	void					SetFlexWeight( LocalFlexController_t index, float value );
	float					GetFlexWeight( const char *szName );
	float					GetFlexWeight( LocalFlexController_t index );

	LocalFlexController_t	FindFlexController( const char *szName );
	bool					IsSuppressedFlexAnimation( CSceneEventInfo *info );

public:
	virtual ~IBaseFlex() {}

	virtual ServerClass*	GetServerClass(void) = 0;
	virtual int				YouForgotToImplementOrDeclareServerClass(void) = 0;
	virtual	datamap_t*		GetDataDescMap(void) = 0;
	virtual void 			SetModel( const char *szModelName ) = 0;
	virtual void			Teleport( const Vector *newPosition, const QAngle *newAngles, const Vector *newVelocity ) = 0;
	virtual	void			SetViewtarget( const Vector &viewtarget ) = 0;
	virtual bool			StartSceneEvent( CSceneEventInfo *info, CChoreoScene *scene, CChoreoEvent *event, CChoreoActor *actor, CBaseEntity *pTarget ) = 0;
	virtual void			ProcessSceneEvents( void ) = 0;
	virtual	bool			ProcessSceneEvent( CSceneEventInfo *info, CChoreoScene *scene, CChoreoEvent *event ) = 0;
	virtual	bool			ClearSceneEvent( CSceneEventInfo *info, bool fastKill, bool canceled ) = 0;
	virtual bool			CheckSceneEventCompletion( CSceneEventInfo *info, float currenttime, CChoreoScene *scene, CChoreoEvent *event ) = 0;
	virtual float			PlayScene( const char *pszScene, float flDelay = 0.0f, AI_Response *response = nullptr, IRecipientFilter *filter = nullptr ) = 0;
	virtual float			PlayAutoGeneratedSoundScene( const char *soundname ) = 0;

private:
	CNetworkArray(float, 	m_flexWeight, 96);
	CNetworkVector(			m_viewtarget);
	CNetworkVar(int, 		m_blinktoggle);
	CUtlVector < CSceneEventInfo >		m_SceneEvents;

	struct FS_LocalToGlobal_t
	{
		explicit FS_LocalToGlobal_t() :
			m_Key( nullptr ),
			m_nCount( 0 ),
			m_Mapping( nullptr )
		{
		}

		explicit FS_LocalToGlobal_t( const flexsettinghdr_t *key ) :
			m_Key( key ),
			m_nCount( 0 ),
			m_Mapping( nullptr )
		{
		}		

		void SetCount( int count )
		{
			Assert( !m_Mapping );
			Assert( count > 0 );
			m_nCount = count;
			m_Mapping = new LocalFlexController_t[ m_nCount ];
			Q_memset( m_Mapping, 0, m_nCount * sizeof( int ) );
		}

		FS_LocalToGlobal_t( const FS_LocalToGlobal_t& src )
		{
			m_Key = src.m_Key;
			m_Mapping = new LocalFlexController_t[ src.m_nCount ];
			Q_memcpy( m_Mapping, src.m_Mapping, src.m_nCount * sizeof( int ) );

			m_nCount = src.m_nCount;
		}

		~FS_LocalToGlobal_t()
		{
			delete m_Mapping;
			m_nCount = 0;
			m_Mapping = 0;
		}

		const flexsettinghdr_t	*m_Key = nullptr;
		int						m_nCount = 0;
		LocalFlexController_t	*m_Mapping = nullptr;
	};

	CUtlRBTree< FS_LocalToGlobal_t, unsigned short > m_LocalToGlobal;
	float				m_flAllowResponsesEndTime;
	CUtlVector < CChoreoScene * >		m_ActiveChoreoScenes;
	bool				m_bUpdateLayerPriorities;
	float				m_flLastFlexAnimationTime;						// 1664
};

inline void IBaseFlex::SetFlexWeight(const char *szName, float value)
{
	SetFlexWeight(FindFlexController(szName), value);
}

inline float IBaseFlex::GetFlexWeight(const char *szName)
{
    return GetFlexWeight(FindFlexController(szName));
}
#endif